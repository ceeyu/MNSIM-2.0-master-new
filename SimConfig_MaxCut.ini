######## Hardware Configuration for Max Cut Applications #####

[Device level]
Device_Tech = 130
# tech unit: nm
Device_Type = NVM
# device type: NVM for RRAM-based Max Cut computing
Device_Area = 1.44
# RRAM area optimized for matrix storage
# area unit: um^2
Read_Level = 8
# Increased read levels for better weight quantization
Read_Voltage = 0,0.05,0.1,0.15,0.2,0.25,0.3,0.35
# More voltage levels for precise weight mapping
# read voltage unit: V
Write_Level = 8
# Write levels matching read levels
Write_Voltage = 0,0.5,1.0,1.5,2.0,2.5,3.0,3.5
# write voltage unit: V
Read_Latency = 3.16
# read latency unit: ns
Write_Latency = 10
# write latency unit: ns
Device_Level = 8
# 8-level resistance for better weight resolution
Device_Resistance = 1e6,5e5,2.5e5,1.25e5,6.25e4,3.125e4,1.56e4,1e4
# Multi-level resistance for weight quantization
# resistence unit: ohm, from HRS to LRS
Device_Variation = 0.5
# Reduced variation for stable Max Cut computation
# x% of ideal resistance
Device_SAF = 0.05,0.05
# Lower stuck-at-fault rate for reliable computation
# X% of Stuck-At-HRS and Stuck-At-LRS
Read_Energy = 1.12e-15
# only used for SRAM, energy per bit
Write_Energy = 1.6e-15
# only used for SRAM, energy per bit

[Crossbar level]
Xbar_Size = 128,128
# Smaller crossbar for better Max Cut matrix partitioning
# (Row, Column) - optimized for typical graph sizes
Subarray_Size = 128
# (Row) - full crossbar as single subarray for Max Cut
# assume the subarray has the same column number as the crossbar
Cell_Type = 1T1R
# 1T1R for precise resistance control in Max Cut
# cell type option: 1T1R, 0T1R, only suitable for NVM
Transistor_Tech = 130
# transistor technology unit: nm
Wire_Resistance = 2.8
# Explicit wire resistance for accurate Max Cut simulation
# wire resistance option: value (unit: ohm) or Default (-1)
Wire_Capacity = 1.0
# Explicit wire capacity for timing analysis
# wire capacity option: value (unit: fF) or Default (-1)
Load_Resistance = -1
# Auto-calculated load resistance
# load resistance (unit:ohm) or Default (-1)
Area_Calculation = 0
# Use device area for computing (more accurate for RRAM)
# different area calculation methods: 0: use device area for computing; 1: use device tech for computing

[Interface level]
DAC_Choice = 4
# Higher precision DAC for Max Cut input vectors
# DAC choice option: -1: User defined, 1~7: SEVEN default configurations
DAC_Area = 0
# DAC area option: 0: default configurations, x: unit um^2
DAC_Precision = 0
# DAC precision option: 0: default configurations, x: unit bit
DAC_Power = 0
# DAC power option: 0: default configurations, x: unit W
DAC_Sample_Rate = 0
# DAC sample rate option: 0: default configurations, x: GSamples/s
ADC_Choice = 5
# Higher precision ADC for Max Cut output processing
# ADC choice option: -1: User defined, 1~8: eight default configurations
ADC_Area = 0
# ADC area option: 0: default configurations, x: unit um^2
ADC_Precision = 0
# ADC precision option: 0: default configurations, x: unit bit
ADC_Power = 0
# ADC power option: 0: default configurations, x: unit W
ADC_Sample_Rate = 0
# ADC sample rate option: 0: default configurations, x: Samples/s
ADC_Interval_Thres = -1
# Auto-configured for Max Cut voltage ranges
# ADC sample interval threshold option: -1 default configurations
Logic_Op = -1
# No additional logic operations needed for Max Cut
# -1: not support, 0: AND, 1: OR, 2: XOR

[Process element level]
PIM_Type = 0
# Analog PIM for efficient Max Cut matrix-vector multiplication
# 0: analog PIM, 1: digital PIM
Xbar_Polarity = 1
# Single polarity for Max Cut (weights can be made non-negative)
# polarity 1: one xbar for both pos and neg; polarity 2: one pos xbar and one neg xbar
Sub_Position = 0
# Not applicable for single polarity
# 0: analog domain subtraction; 1: digital domain subtraction
Group_Num = 4
# Multiple groups for parallel Max Cut vector processing
# number of crossbar groups
DAC_Num = 64
# Sufficient DACs for Max Cut input parallelism
# number of DAC per *subarray* in each group
ADC_Num = 64
# Sufficient ADCs for Max Cut output parallelism
# number of ADC per *subarray* in each group
PE_inBuf_Size = 32
# Larger input buffer for Max Cut vectors
# the input buffer size in each PE: 0: default configuration, x: KB
PE_inBuf_Area = 0
# PE input buffer area option: 0: default configurations, x: um^2
Tile_outBuf_Size = 64
# Larger output buffer for Max Cut results
Tile_outBuf_Area = 0
DFU_Buf_Size = 16
DFU_Buf_Area = 0

[Digital module]
Digital_Frequency = 1000
# Higher frequency for faster Max Cut iteration
# digital part frequency unit: MHz
Adder_Tech = 45
# Advanced technology for efficient addition
# adder technology unit: nm
Adder_Area = 0
# adder area option: 0:default configurations x: unit um^2
Adder_Power = 0
# adder power option: 0:default configurations x: unit W
Multiplier_Tech = 45
# Advanced multiplier technology
Multiplier_Area = 0
Multiplier_Power = 0
ShiftReg_Tech = 45
# shiftreg technology unit: nm
ShiftReg_Area = 0
# shiftreg area option: 0:default configurations x: unit um^2
ShiftReg_Power = 0
# shiftreg power option: 0:default configurations x: unit W
Reg_Tech = 45
# register technology unit: nm
Reg_Area = 0
# register area option: 0:default configurations x: unit um^2
Reg_Power = 0
# register power option: 0:default configurations x: unit W
JointModule_Tech = 45
# JointModule technology unit: nm
JointModule_Area = 0
# jointmodule area option: 0:default configurations x: unit um^2
JointModule_Power = 0
# jointmodule power option: 0:default configurations x: unit W

[Tile level]
PE_Num = 4,4
# More PEs for parallel Max Cut processing
# number of PEs in each tile (x,y)
Pooling_shape = 1,1
# Minimal pooling for Max Cut (not needed)
# Pooling Kernel size
Pooling_unit_num = 1
# Minimal pooling units
# the Pooling unit in a tile
Pooling_Tech = 65
# technology for pooling unit used, unit is nm
Pooling_area = 0
# area for total Pooling part in the tile
Tile_Adder_Num = 16
# More adders for Max Cut result aggregation
# number of adders in each tile
Tile_Adder_Level = 4
# Deep adder tree for efficient summation
# max adder level in each tile
Tile_ShiftReg_Num = 64
# Sufficient shift registers
# number of shiftregs in each tile
Tile_ShiftReg_Level = 4
# max shiftreg level in each tile
Inter_Tile_Bandwidth = 50
# Higher bandwidth for Max Cut data exchange
# inter tile bandwidth, unit: Gbps
Intra_Tile_Bandwidth = 2048
# Higher intra-tile bandwidth
# intra tile bandwidth (inter PE), unit: Gbps
Tile_outBuf_Size = 128
# Larger tile output buffer for Max Cut results
# the output buffer size in each Tile: KB
Tile_outBuf_Area = 0
# Tile output buffer area option: 0: default configurations, x: um^2
DFU_Buf_Size = 32
# Larger DFU buffer for Max Cut data forwarding
# the buffer size in Data Forwarding Unit of each Tile: KB
DFU_Buf_Area = 0
# DFU buffer area option: 0: default configurations, x: um^2

[Architecture level]
Buffer_Choice = 1
# SRAM buffers for fast Max Cut data access
# buffer choice option: 0: User defined, 1: SRAM, 2:DRAM, 3:RRAM
Buffer_Technology = 65
# Advanced buffer technology
# buffer technology option: 0: default configurations, x:nm
Buffer_ReadPower = 0
# buffer read power option: 0: default configurations, x:mW
Buffer_WritePower = 0
# buffer write power option: 0: default configurations, x:mW
Buffer_Bitwidth = 128
# Wider bitwidth for Max Cut data parallelism
# buffer bitwidth option: 0: default configurations, x:bit

LUT_Capacity = 2
# Larger LUT for Max Cut algorithm parameters
# LUT capacity unit: Mb
LUT_Area = 0
# LUT area option: 0: default configurations, x: mm^2
LUT_Power = 0
# LUT power option: 0: default configurations, x:mW
LUT_Bandwidth = 0
# LUT bandwidth option: 0: default configurations, x:Mb/s
Tile_Connection = 2
# Mesh connection for Max Cut tile communication
# Option: 0, 1, 2, 3

Tile_Num = 16,16
# More tiles for large Max Cut problems
# number of Tiles in accelerator (x,y)

########### Algorithm Configuration ################

[Algorithm Configuration]
Weight_Polarity = 1
# Single polarity for Max Cut weights
# 1 or 2
Simulation_Level = 1
# Detailed simulation for accurate Max Cut modeling
# 0: Behavior; 1: Estimation (consider specific weight values)
NoC_enable = 1
# Enable NoC simulation for large Max Cut problems
# 0: not call booksim; 1: Call booksim to simulate NoC
